const { app, BrowserWindow, ipcMain, dialog, Menu, shell, clipboard } = require('electron');
app.name = 'Auto-Git';
const { exec } = require('child_process');
const path = require('path');
const fs = require('fs');
const Store = require('electron-store');
const simpleGit = require('simple-git');
const chokidar = require('chokidar');

const store = new Store({
  defaults: {
    folders: [],
    selected: null,
    skymode: true,
    skipGitPrompt: true
  }
});

// Map zum Speichern der Watcher pro Ordner
const repoWatchers = new Map();



// Debug Helper
function debug(msg) {
  console.log(`[DEBUG ${new Date().toISOString()}] ${msg}`);
}


/**
 * Erstellt das BrowserWindow und lädt index.html.
 * Gibt das Window-Objekt zurück.
 */
function createWindow() {
  const win = new BrowserWindow({
    width: 900,
    height: 600,
    minWidth: 600,
    minHeight: 400,
    title: 'Auto-Git',
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      contextIsolation: true
    }
  });
  win.loadFile('index.html');
  return win;
}


// Settings-Fenster
let settingsWin;
function openSettings(win) {
  if (settingsWin) {
    settingsWin.focus();
    return;
  }
 settingsWin = new BrowserWindow({
   parent: win,
   modal: true,
   width: 400,
   height: 300, 
   resizable: false,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      contextIsolation: true
    }
  });
  settingsWin.removeMenu();
  settingsWin.loadFile('settings.html');
  settingsWin.on('closed', () => settingsWin = null);
}


/**
 * Startet einen File-Watcher auf .git/refs/heads/master,
 * sendet bei Änderungen 'repo-updated' an den Renderer.
 */
function watchRepo(folder, win) {
  const gitHead = path.join(folder, '.git', 'refs', 'heads', 'master');
  const watcher = chokidar.watch(gitHead, { ignoreInitial: true });
  watcher.on('change', () => {
    win.webContents.send('repo-updated', folder);
  });
  repoWatchers.set(folder, watcher);
}

/**
 * Initiiert ein Git-Repo in `folder`, falls noch nicht vorhanden,
 * und erzeugt einen Initial-Commit mit Timestamp.
 */
async function initGitRepo(folder) {
  const git = simpleGit(folder);
  const gitDir = path.join(folder, '.git');
  if (!fs.existsSync(gitDir)) {
    await git.init();
    const message = `Initial commit (generated by auto-git)`;
    const readmePath = path.join(folder, 'README.md');
    fs.writeFileSync(readmePath, `# Projekt in ${path.basename(folder)}\n`);
    await git.add('./*');
    await git.commit(message);
  }
}


// Map für Monitoring-Watcher (nicht repoWatchers!)
const monitoringWatchers = new Map();

function startMonitoringWatcher(folderPath, win) {
  // Nicht mehrfach starten
  if (monitoringWatchers.has(folderPath)) return;
  const watcher = chokidar.watch(folderPath, {
    ignored: /(^|[\/\\])\..|node_modules|\.git/, // ignoriert .git und .dot-Dateien + node_modules
    ignoreInitial: true,
    persistent: true,
    depth: 99, // Rekursiv
    awaitWriteFinish: {
      stabilityThreshold: 300,
      pollInterval: 100
    }
  });

  // TODO: Optionale .gitignore Logik nachrüsten

  watcher.on('all', async (event, changedPath) => {
    debug(`[MONITOR] ${event} in ${changedPath}`);
    // Hier einfach auto-commit Funktion rufen:
    await autoCommit(folderPath, `[auto] ${event} ${path.relative(folderPath, changedPath)}`);
    // Repo-UI aktualisieren:
    win.webContents.send('repo-updated', folderPath);
  });

  // Initialer Commit, falls beim Start schon ungestagte Änderungen vorliegen
  (async () => {
    debug(`[MONITOR] Starte initialen Commit-Check für ${folderPath}`);

    const git = simpleGit(folderPath);
    const status = await git.status();

    // Alle betroffenen Pfade sammeln und je nach Typ annotieren
    const changes = [];
    status.not_added.forEach(f => changes.push(`add ${f}`));
    status.created.forEach(f   => changes.push(`add ${f}`));
    status.modified.forEach(f  => changes.push(`change ${f}`));
    status.deleted.forEach(f   => changes.push(`unlink ${f}`));
    status.renamed.forEach(r   => changes.push(`[rename] ${r.from} → ${r.to}`));

    if (changes.length > 0) {
      // Commit-Message so bauen wie beim Event (eine Zeile pro Datei)
      const msg = `[auto]` + changes.map(l => ` ${l}`).join('\n');
      const did = await autoCommit(folderPath, msg);
      if (did) {
        win.webContents.send('repo-updated', folderPath);
        debug(`[MONITOR] Initialer Auto-Commit für ${folderPath} durchgeführt:\n${msg}`);
      }
    }
  })();

  monitoringWatchers.set(folderPath, watcher);
  debug(`[MONITOR] Watcher aktiv für ${folderPath}`);
}

function stopMonitoringWatcher(folderPath) {
  const watcher = monitoringWatchers.get(folderPath);
  if (watcher) {
    watcher.close();
    monitoringWatchers.delete(folderPath);
    debug(`[MONITOR] Watcher gestoppt für ${folderPath}`);
  }
}

async function autoCommit(folder, message) {
  const git = simpleGit(folder);
  const status = await git.status();
  if (
    status.not_added.length === 0 &&
    status.created.length   === 0 &&
    status.deleted.length   === 0 &&
    status.modified.length  === 0 &&
    status.renamed.length   === 0
  ) {
    debug('Auto-Commit: Keine Änderungen zum committen.');
    return false;
  }
  // Der Rest wie in commit-current-folder
  let currentBranch = null;
  try {
    currentBranch = (await git.revparse(['--abbrev-ref', 'HEAD'])).trim();
    debug(`[autoCommit] Aktueller Branch: ${currentBranch}`);
  } catch {
    debug('[autoCommit] HEAD ist detached.');
  }
  if (!currentBranch || currentBranch === 'HEAD') {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupBranch = `backup-master-${timestamp}`;
    const branches = await git.branchLocal();
    if (branches.all.includes('master')) {
      await git.branch(['-m', 'master', backupBranch]);
      debug(`[autoCommit] Alter master in ${backupBranch} umbenannt.`);
    }
    await git.checkout(['-b', 'master']);
    debug('[autoCommit] Neuer master-Branch erstellt und ausgecheckt.');
  }
  await git.add(['-A']);
  debug('[autoCommit] Alle Änderungen gestaged.');
  await git.commit(message || '[auto]');
  debug('[autoCommit] Commit erfolgreich erstellt.');
  return true;
}

app.whenReady().then(() => {
  const win = createWindow();

  // Menüs
  const menu = Menu.buildFromTemplate([
    {
      role: 'appMenu',
      submenu: [
        {
          label: 'Settings', click: () => openSettings(win)
        },
        { role: 'quit', label: 'Quit' }
      ]
    }, // mehr menüs hier
  ]);
  Menu.setApplicationMenu(menu);

  // 1) Beim Start bereits gespeicherte Ordner überwachen und monitoren
  const folders = store.get('folders') || [];
  folders.forEach(folderObj => {
    if (fs.existsSync(path.join(folderObj.path, '.git', 'refs', 'heads', 'master'))) {
      watchRepo(folderObj.path, win);
    }
    if (folderObj.monitoring) {
      startMonitoringWatcher(folderObj.path, win);
    }
  });

  // 2) IPC-Handler
  ipcMain.handle('get-selected', () => {
    const folders = store.get('folders') || [];
    const selectedPath = store.get('selected');
    return folders.find(f => f.path === selectedPath) || null;
  });

  ipcMain.handle('set-selected', (_e, folderObjOrPath) => {
    // Akzeptiert sowohl String (legacy) als auch Objekt:
    const folderPath = typeof folderObjOrPath === 'string'
      ? folderObjOrPath
      : folderObjOrPath.path;
    store.set('selected', folderPath);
    const folders = store.get('folders') || [];
    return folders.find(f => f.path === folderPath) || null;
  });

  // Liste aller Folders
  ipcMain.handle('get-folders', () => store.get('folders'));


  // Ordner hinzufügen: Open-Dialog, init, Store-Update, watchen, monitoren
  ipcMain.handle('add-folder', async () => {
    const { canceled, filePaths } = await dialog.showOpenDialog({
      properties: ['openDirectory']
    });
    if (canceled || !filePaths[0]) {
      return store.get('folders');
    }
    const newFolder = filePaths[0];
    await initGitRepo(newFolder);
    let folders = store.get('folders') || [];
    let folderObj = folders.find(f => f.path === newFolder);
    if (!folderObj) {
      folderObj = { path: newFolder, monitoring: true };
      folders.push(folderObj);
      store.set('folders', folders);
    }
    store.set('selected', newFolder);
    watchRepo(newFolder, win);
    startMonitoringWatcher(newFolder, win);
    return store.get('folders');
  });
/*
  ipcMain.handle('add-folder', async () => {
    const { canceled, filePaths } = await dialog.showOpenDialog({ properties: ['openDirectory'] });
    if (canceled || !filePaths[0]) return store.get('folders');
    const newFolder = filePaths[0];

    // Repo initialisieren
    await initGitRepo(newFolder);

    // Im Store ablegen
    const current = store.get('folders');
    if (!current.includes(newFolder)) {
      store.set('folders', [...current, newFolder]);
    }
    store.set('selected', newFolder);

    // und watchen
    watchRepo(newFolder, win);

    return store.get('folders');
  });
*/
  // Ordner entfernen: Watcher schließen, Store-Update
  ipcMain.handle('remove-folder', (_e, folderObj) => {
    const folders = store.get('folders') || [];
    const updated = folders.filter(f => f.path !== folderObj.path);
    store.set('folders', updated);
    if (store.get('selected') === folderObj.path) store.set('selected', null);
    stopMonitoringWatcher(folderObj.path);
    const watcher = repoWatchers.get(folderObj.path);
    if (watcher) watcher.close(), repoWatchers.delete(folderObj.path);
    return updated;
  });

/*
  ipcMain.handle('get-selected', () => store.get('selected'));
  ipcMain.handle('set-selected', (_e, folderPath) => {
    store.set('selected', folderPath);
    return folderPath;
  });
  */
  /*
  ipcMain.handle('remove-folder', (_e, folder) => {
    const watcher = repoWatchers.get(folder);
    if (watcher) {
      watcher.close();
      repoWatchers.delete(folder);
    }
    const updated = store.get('folders').filter(f => f !== folder);
    store.set('folders', updated);
    if (store.get('selected') === folder) {
      store.set('selected', null);
    }
    return updated;
  });
  */


  // Zähle Commits
    ipcMain.handle('get-commit-count', async (_e, folderObj) => {
    const git = simpleGit(folderObj.path);
    const log = await git.log();
    return log.total; // Anzahl der Commits
  });

  // Prüfe, ob es ungestagte Änderungen gibt
  ipcMain.handle('has-diffs', async (_e, folderObj) => {
    const git = simpleGit(folderObj.path);
    const status = await git.status();
    // modified, not_added, deleted, etc.
    return status.files.length > 0;
  });

  // Entferne das .git-Verzeichnis
  ipcMain.handle('remove-git-folder', async (_e, folderObj) => {
    const gitDir = path.join(folderObj.path, '.git');
    if (fs.existsSync(gitDir)) {
      await fs.promises.rm(gitDir, { recursive: true, force: true });
    }
    return;
  });

/*
  // Selected
  ipcMain.handle('get-selected', () => store.get('selected'));
  ipcMain.handle('set-selected', (_e, folder) => {
    store.set('selected', folder);
    return folder;
  });
  */

  // Commits holen
  ipcMain.handle('get-commits', async (_e, folderObj) => {
    const git = simpleGit(folderObj.path);
    // alle Commits holen
    const log = await git.log(['--all']);
    // aktuellen HEAD‐Hash ermitteln
    const fullHead = (await git.revparse(['--verify', 'HEAD'])).trim();
    const head     = fullHead.substring(0, 7);
    return {
      head, 
      commits: log.all.map(c => ({
        hash:    c.hash.substring(0, 7),
        date:    c.date,
        message: c.message
      }))
    };
  });

  // Diff
  ipcMain.handle('diff-commit', async (_e, folderObj, hash) => {
    const git = simpleGit(folderObj.path);
    return git.diff([`${hash}^!`]);
  });

  // Revert
  ipcMain.handle('revert-commit', async (_e, folderObj, hash) => {
    const git = simpleGit(folderObj.path);
    await git.revert(hash, ['--no-edit']);
  });

  /**
   * Checkt das Arbeitsverzeichnis auf exakt den Zustand von `hash` aus.
   */
  ipcMain.handle('checkout-commit', async (_e, folderObj, hash) => {
    const git = simpleGit(folderObj.path);
    // clean mode: alle lokalen Veränderungen verwerfen
    await git.checkout([hash, '--force']);
  });


  // Snapshot
  ipcMain.handle('snapshot-commit', async (_e, folderObj, hash) => {
    const { canceled, filePaths } = await dialog.showOpenDialog({
      title: 'Ordner auswählen zum Speichern des Snapshots',
      properties: ['openDirectory']
    });
    if (canceled || !filePaths[0]) return;
    const outDir   = filePaths[0];
    const baseName = path.basename(folderObj.path);
    const filePath = path.join(outDir, `${baseName}-${hash}.zip`);
    return new Promise((resolve, reject) => {
      exec(
        `git -C "${folderObj.path}" archive --format zip --output "${filePath}" ${hash}`,
        err => err ? reject(err) : resolve(filePath)
      );
    });
  });


   // IPC für skymode
  ipcMain.handle('get-skymode', () => store.get('skymode'));
  ipcMain.handle('set-skymode', (_e, val) => {
    store.set('skymode', val);
    // sende an alle Fenster
    BrowserWindow.getAllWindows().forEach(win => {
      win.webContents.send('skymode-changed', val);
    });
  });
  ipcMain.handle('get-skip-git-prompt', ()    => store.get('skipGitPrompt'));
  ipcMain.handle('set-skip-git-prompt', (_e,val) => store.set('skipGitPrompt', val));





  ipcMain.handle('commit-current-folder', async (_e, folderObj, message) => {
    folder = folderObj.path;
    try {
      debug(`Commit-Vorgang für ${folder} gestartet…`);
      const git = simpleGit(folder);

      // Prüfe: Gibt es was zu committen?
      const status = await git.status();
      if (
        status.not_added.length === 0 &&
        status.created.length   === 0 &&
        status.deleted.length   === 0 &&
        status.modified.length  === 0 &&
        status.renamed.length   === 0
      ) {
        debug('Nichts zu committen.');
        return { success: false, error: 'Nichts zu committen.' };
      }

      // HEAD-Status prüfen
      let currentBranch = null;
      try {
        currentBranch = (await git.revparse(['--abbrev-ref', 'HEAD'])).trim();
        debug(`Aktueller Branch: ${currentBranch}`);
      } catch (err) {
        debug('HEAD ist detached.');
      }

      // Falls detached, **jetzt erst** alten Branch umbenennen und neuen master erzeugen
      if (!currentBranch || currentBranch === 'HEAD') {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const backupBranch = `backup-master-${timestamp}`;

        // Alten master umbenennen (nur falls vorhanden!)
        const branches = await git.branchLocal();
        if (branches.all.includes('master')) {
          await git.branch(['-m', 'master', backupBranch]);
          debug(`Alter master-Branch wurde in ${backupBranch} umbenannt.`);
        }
        // Neuer master-Branch
        await git.checkout(['-b', 'master']);
        debug('Neuer master-Branch erstellt und ausgecheckt.');
      }

      await git.add(['-A']);
      debug('Alle Änderungen gestaged.');
      await git.commit(message || 'test');
      debug('Commit erfolgreich erstellt.');
      // Push hier ggf. noch auskommentiert lassen

      return { success: true };
    } catch (err) {
      debug(`FEHLER beim Commit: ${err.message}`);
      return { success: false, error: err.message };
    }
  });

  ipcMain.handle('set-monitoring', async (_e, folderPath, monitoring) => {
    let folders = store.get('folders') || [];
    folders = folders.map(f =>
      f.path === folderPath ? { ...f, monitoring } : f
    );
    store.set('folders', folders);
    debug(`[STORE] Monitoring für ${folderPath}: ${monitoring}`);
    // Monitoring-Watcher starten/stoppen → gleich mehr dazu
    if (monitoring) {
      startMonitoringWatcher(folderPath, win);
    } else {
      stopMonitoringWatcher(folderPath);
    }
    return monitoring;
  });


  // … Ende der IPC-Handler …
});

ipcMain.on('show-folder-context-menu', (event, folderPath) => {
  const win = BrowserWindow.fromWebContents(event.sender);
  const template = [
    {
      label: 'Copy Folder Path',
      click: () => {
        clipboard.writeText(folderPath);
      }
    },
    {
      label: 'Open Folder',
      click: () => {
        // öffnet den Ordner in der nativen Dateiansicht
        shell.openPath(folderPath);
      }
    }
  ];
  const menu = Menu.buildFromTemplate(template);
  menu.popup({ window: win });
}); 

// clean up on exit
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') app.quit();
});
